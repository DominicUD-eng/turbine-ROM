import numpy as np
from scipy.integrate import solve_ivp

class SteadyCFDSolver:
    """
    Assumptions (explicit):
      1) Axisymmetric, thin film of uniform thickness h, no axial variation; incompressible.
      2) Enforce steady continuity: 2π r h rho vr = m_dot  (thus vr = m_dot/(2π r h rho)).
      3) Model vtheta dynamics by diffusion in r (eddy viscosity neglected) + wall coupling.
      4) Outer boundary: vtheta(r_out) specified via initial guess; Inner boundary: zero-torque Neumann (∂vθ/∂r = 0) for stability.
      5) Outlet gauge pressure = 0 is not explicitly used by the model (mass flow is prescribed). You can later couple p_out to m_dot.
    """

    def __init__(self, disk_props, mesh, m_dot: float, vtheta_init: float,
                 omega_init: float, t_max: float = 500.0, tol_v: float = 1e-4, tol_om: float = 1e-6):
        self.dp = disk_props
        self.mesh = mesh
        self.N = mesh.n
        self.m_dot = m_dot
        self.vtheta_init = vtheta_init
        self.omega_init = omega_init
        self.t_max = t_max
        self.tol_v = tol_v
        self.tol_om = tol_om

        # initialize fields
        self.mesh.set_vtheta(np.full(self.N, vtheta_init, dtype=float)) #Fills in the array with the initial
        self.vr_continuity_update()

    def vr_continuity_update(self):
        r = self.mesh.rs
        rho, h = self.dp.rho, self.dp.film_thickness
        # Avoid r=0. Our mesh uses r_in>0.
        vr = self.m_dot / (2.0 * np.pi * r * h * rho)
        self.mesh.set_vr(vr)
        
    def _laplacian_r(self, phi):
        # second-order central differences on uniform radial grid (approximately uniform)
        dr = self.mesh.dr
        N = self.N
        Lphi = np.zeros_like(phi)
        r = self.mesh.rs

        # interior nodes: (1/r d/dr(r dphi/dr)) ≈ (1/r_i)*[(r_{i+1/2}*(phi_{i+1}-phi_i)/dr - r_{i-1/2}*(phi_i-phi_{i-1})/dr)/dr]
        # For simplicity on quasi-uniform grid, use a conservative form:
        for i in range(1, N-1):
            rp = 0.5*(r[i]+r[i+1])
            rm = 0.5*(r[i]+r[i-1])
            Lphi[i] = ( rp*(phi[i+1]-phi[i]) - rm*(phi[i]-phi[i-1]) ) / (r[i]*dr*dr)

        # Boundary conditions:
        # Outer boundary (i=0): Dirichlet hold phi[0] fixed by zeroing Laplacian contribution (handled via ODE coupling)
        Lphi[0] = 0.0
        # Inner boundary (i=N-1): Neumann ∂phi/∂r = 0 => phi[N-1] ~ phi[N-2]
        Lphi[N-1] = ( (0.5*(r[N-1]+r[N-2]))*(phi[N-2]-phi[N-1]) ) / (r[N-1]*dr*dr)  # one-sided approx

        return Lphi

    def _rhs(self, t, y):
        # unpack
        vtheta = y[:self.N]
        omega = y[self.N]

        r = self.mesh.rs
        mu, rho, h, I = self.dp.mu, self.dp.rho, self.dp.film_thickness, self.dp.I

        # ensure vr consistent with current (constant) m_dot
        # (m_dot is constant in this simple model; if you later couple pressure, recompute here)
        vr = self.mesh.get_vr()

        # Viscous radial diffusion term ν * ∇_r^2 vtheta
        nu = mu / rho
        lap = self._laplacian_r(vtheta)

        # Wall coupling: relax vtheta toward solid-body omega*r across film h
        # Represent as ν/h^2 * (omega*r - vtheta)
        wall_coupling = nu/(h*h) * (omega*r - vtheta)

        dvtheta_dt = wall_coupling + nu*lap
        # Simple upwind/convective stabilization could add: - vr * dvtheta/dr (omitted for simplicity)

        # Disk spin-down from shear: tau = mu*(omega*r - vtheta)/h
        # dTorque = tau * (2π r dr) * r  => T = ∑ mu*(omega*r_i - vtheta_i)/h * 2π r_i * dr * r_i
        dr = self.mesh.dr
        tau = mu*(omega*r - vtheta)/h
        ring_circ = 2.0*np.pi*r
        dT = tau * ring_circ * dr * r
        Torque = np.sum(dT)
        domega_dt = - Torque / I

        # Stopping criteria via event functions handled outside; here just return derivatives
        return np.concatenate([dvtheta_dt, [domega_dt]])

    def _events(self):
        # For clean termination: when max|dvtheta/dt| < tol_v and |domega/dt| < tol_om
        def ev_v(t, y):
            vtheta = y[:self.N]
            omega = y[self.N]
            dy = self._rhs(t, y)
            dv = dy[:self.N]
            return np.max(np.abs(dv)) - self.tol_v
        ev_v.terminal = True
        ev_v.direction = -1.0

        def ev_om(t, y):
            dy = self._rhs(t, y)
            return abs(dy[-1]) - self.tol_om
        ev_om.terminal = True
        ev_om.direction = -1.0

        return (ev_v, ev_om)

    def solve(self):
        # initial state
        y0 = np.concatenate([self.mesh.get_vtheta(), [self.omega_init]])

        # integrate
        sol = solve_ivp(self._rhs, t_span=(0.0, self.t_max), y0=y0,
                        method="BDF", rtol=1e-6, atol=1e-8, events=self._events())

        # write back final state
        vtheta_f = sol.y[:self.N, -1]
        omega_f  = sol.y[self.N, -1]
        self.mesh.set_vtheta(vtheta_f)

        return {
            "success": sol.success,
            "message": sol.message,
            "t_end": float(sol.t[-1]),
            "vtheta": vtheta_f.copy(),
            "vr": self.mesh.get_vr().copy(),
            "omega": float(omega_f),
            "events_t": [float(t) for t in getattr(sol, "t_events", []) if len(t)>0] if hasattr(sol, "t_events") else []
        }
